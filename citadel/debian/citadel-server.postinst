#! /bin/sh
# postinst.skeleton
# Skeleton maintainer script showing all the possible cases.
# Written by Charles Briscoe-Smith, March-June 1998.  Public Domain.

# Abort if any command returns an error value
set -e

# Use debconf.
. /usr/share/debconf/confmodule

# This script is called as the last step of the installation of the
# package.  All the package's files are in place, dpkg has already done
# its automatic conffile handling, and all the packages we depend of
# are already fully installed and configured.

# The following idempotent stuff doesn't generally need protecting
# against being run in the abort-* cases.

#### Install info files into the dir file
###: install-info --quiet --section "section pattern" "Section Title" \
###:              --description="Name of the document" /usr/info/foo.info
###
#### Create stub directories under /usr/local
###: if test ! -d /usr/local/lib/foo; then
###:   if test ! -d /usr/local/lib; then
###:     if mkdir /usr/local/lib; then
###:       chown root.staff /usr/local/lib || true
###:       chmod 2775 /usr/local/lib || true
###:     fi
###:   fi
###:   if mkdir /usr/local/lib/foo; then
###:     chown root.staff /usr/local/lib/foo || true
###:     chmod 2775 /usr/local/lib/foo || true
###:   fi
###: fi
###
#### Ensure the menu system is updated
###: [ ! -x /usr/bin/update-menus ] || /usr/bin/update-menus
###
#### Arrange for a daemon to be started at system boot time
###: update-rc.d foo default >/dev/null
###



case "$1" in
  configure)
    # Configure this package.  If the package must prompt the user for
    # information, do it here.
    if ! getent group citadel >/dev/null; then 
		groupadd citadel
	fi
	if ! getent passwd citadel >/dev/null; then 
		adduser --system --ingroup citadel --home /var/lib/citadel \
			--gecos "Citadel system user" --shell /bin/sh \
			--disabled-password citadel
	fi
	mkdir -p /etc/citadel
	chown citadel:citadel /etc/citadel
    # Activate menu-methods script
    #: chmod a+x /etc/menu-methods/foo

    # Update ld.so cache
    #: ldconfig

    # Make our version of a program available
    #: update-alternatives \
    #:       --install /usr/bin/program program /usr/bin/alternative 50 \
    #:       --slave /usr/share/man/man1/program.1.gz program.1.gz \
    #:               /usr/share/man/man1/alternative.1.gz

    # Tell ucf that the file in /usr/share/foo is the latest
    # maintainer version, and let it handle how to manage the real
    # confuguration file in /etc. This is how a static configuration
    # file can be handled:
    ucf /usr/share/doc/citadel-server/examples/mail.aliases /etc/citadel/mail.aliases
    ucf /usr/share/doc/citadel-server/examples/public_clients /etc/citadel/public_clients

	#: !TODO: should network/systems  go to /etc/citadel?

	mkdir -p \
		/var/lib/citadel/help \
		/var/lib/citadel/messages \
		/var/lib/citadel/data/ \
		/var/lib/citadel/bio/ \
		/var/lib/citadel/bitbucket/ \
		/var/lib/citadel/files/ \
		/var/lib/citadel/images/ \
		/var/lib/citadel/info/ \
		/var/lib/citadel/userpics/ \
		/var/spool/citadel/network/spoolin \
		/var/spool/citadel/network/spoolout \
		/var/spool/citadel/network/spoolsystems \
		/var/run/citadel


    mkdir -p /var/lib/citadel/help
	for i in   aide  floors  hours  intro.gz  mail  network  nice.gz  policy  software  summary.gz; do
		case $i in 
			*.gz)
				j=`echo $i|sed "s;.gz;;"`
				gunzip -c "/usr/share/doc/citadel-server/examples/help/$i" >"/tmp/$j"
				i=$j
				;;
			*)
				cp "/usr/share/doc/citadel-server/examples/help/$i" "/tmp"
				;;
		esac
		ucf "/tmp/$i" "/var/lib/citadel/help/$i"
		rm -f "/tmp/$i"
	done
	
#	# TODO: there is a file named '?'. this gives trouble with ucf, so do it by hand for now.
#	if test ! -e '/var/lib/citadel/help/?'; then 
#		cp '/usr/share/doc/citadel/examples/data/help/?' '/var/lib/citadel/help'
#	fi
	mkdir -p /var/lib/citadel/messages
	for i in aideopt  changepw  dotopt  entermsg  entopt  goodbye  hello  help  mainmenu  newuser  readopt  register  roomaccess  unlisted; do
		ucf "/usr/share/doc/citadel-server/examples/messages/$i" "/var/lib/citadel/messages/$i"

	done

	chown -R citadel:citadel /var/lib/citadel /var/run/citadel /var/spool/citadel

    ### We could also do this on the fly. The following is from Tore
    ### Anderson:
    
    #. /usr/share/debconf/confmodule

    ### find out what the user answered.
    #  db_get foo/run_on_boot
    #  run_on_boot=$RET

    ### safely create a temporary file to generate our suggested
    ### configuration file.
    #    tempfile=`tempfile`
    #    cat << _eof > $tempfile
    ### Configuration file for Foo.

    ### this was answered by you, the user in a debconf dialogue
    #  RUNONBOOT=$run_on_boot

    ### this was not, as it has a sane default value.
    #  COLOUROFSKY=blue

    #_eof

    ### Note that some versions of debconf do not release stdin, so
    ### the following invocation of ucf may not work, since the stdin
    ### is never coneected to ucfr.

    ### now, invoke ucf, which will take care of the rest, and ask
    ### the user if he wants to update his file, if it is modified.
    #ucf $tempfile /etc/foo.conf

    ### done! now we'll just clear up our cruft.
    #rm -f $tempfile
        chown root:root /usr/sbin/chkpwd
        chmod 4755 /usr/sbin/chkpwd

	db_get citadel/Administrator && admin="$RET"
	db_get citadel/ServerIPAddress && ip_addr="$RET"
	db_get citadel/LoginType && enable_unix_auth="$RET"
	if test "$enable_unix_auth" = "true"; then
	    export ENABLE_UNIX_AUTH=yes
	else
	    export ENABLE_UNIX_AUTH=no
	fi
	export IP_ADDR=$ip_addr
	export CITADEL=''
	export CITADEL_INSTALLER=yes
	export ACT_AS_MTA=no
	export SYSADMIN_NAME=$admin
	export CREATE_XINETD_ENTRY=no
	export CREATE_INITTAB_ENTRY=no
	export NO_INIT_SCRIPTS=yes
	echo "applying your settings."
	/usr/lib/citadel-server/setup -q
	if test -S /var/run/citadel/citadel.socket; then 
	    /usr/sbin/sendcommand "DOWN"
	fi

	while test -S /var/run/citadel/citadel.socket; do 
	    sleep 1
	done

	db_stop
	
	#DEBHELPER#
    #### There are three sub-cases:
    ###if test "${2+set}" != set; then
    ###  # We're being installed by an ancient dpkg which doesn't remember
    ###  # which version was most recently configured, or even whether
    ###  # there is a most recently configured version.
    ###  :
	###
    ###elif test -z "$2" -o "$2" = "<unknown>"; then
    ###  # The package has not ever been configured on this system, or was
    ###  # purged since it was last configured.
    ###  :
	###
    ###else
    ###  # Version $2 is the most recently configured version of this
    ###  # package.
    ###  :
	###
    ###fi 
	;;
  abort-upgrade)
    # Back out of an attempt to upgrade this package FROM THIS VERSION
    # to version $2.  Undo the effects of "prerm upgrade $2".
    #:

    ;;
  abort-remove)
    ###if test "$2" != in-favour; then
    ###  echo "$0: undocumented call to \`postinst $*'" 1>&2
    ###  exit 0
    ###fi
    #### Back out of an attempt to remove this package, which was due to
    #### a conflict with package $3 (version $4).  Undo the effects of
    #### "prerm remove in-favour $3 $4".
    ###:

    ;;
  abort-deconfigure)
    ###if test "$2" != in-favour -o "$5" != removing; then
    ###  echo "$0: undocumented call to \`postinst $*'" 1>&2
    ###  exit 0
    ###fi
    #### Back out of an attempt to deconfigure this package, which was
    #### due to package $6 (version $7) which we depend on being removed
    #### to make way for package $3 (version $4).  Undo the effects of
    #### "prerm deconfigure in-favour $3 $4 removing $6 $7".
    ###:

    ;;
  *) echo "$0: didn't understand being called with \`$1'" 1>&2
     exit 0;;
esac


exit 0
